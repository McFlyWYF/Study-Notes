# 回溯法

* 回溯法是基于树搜索策略演化的一种算法。
* 回溯法的基本做法是搜索，或是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法。这种方法适用于解一些组合数相当大的问题。
* 回溯法在包含问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。
* 解空间也就是进行穷举的搜索空间，所以，解空间中应该包括所有的可能解。
* 例如9.1 子集和问题。
  * 给定n个正整数wi和M。要求从集合（w1,w2,...,wn）中找出所有可能的子集，使每一个子集中各元素的累加和等于M。例：令（w1,w2,w3,w4）=（11，13，24，7）和M=31。那么，满足要求的子集只有两个，即（11，13，7）和（24，7）。但问题的所有可能解为{(),(11),(13),(24),(7),(11,13),(11,24),(11,7),(13,24),(24,7),(11,13,24),(11,13,7),(11,24,7),(13,24,7),(11,13,24,7)}。
  * ![1542543110969](C:\Users\16500\AppData\Local\Temp\1542543110969.png)
  * 左结点是包括这个元素，右结点是不包括。
  * 时间复杂度为O（2^n）。
* 旅行商售货员问题
  * 某售货员要到若干城市推销商品，已知各个城市之间的路程（或旅费）。他要选一条从驻地出发，经过每个城市一遍，最后回到驻地的路线，使总的路程（或总旅费）最小。

![1542543224772](C:\Users\16500\AppData\Local\Temp\1542543224772.png)

![1542543228091](C:\Users\16500\AppData\Local\Temp\1542543228091.png)

时间复杂度为O（n!）。

* 装载问题
  * 如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。
    * (1)首先将第一艘轮船尽可能装满；
    * (2)将剩余的集装箱装上第二艘轮船。
    * 将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近c1。由此可知，装载问题等价于以下特殊的0-1背包问题。

$$
求和(w_ix_i) ≤c_1
$$

* 装载问题

  * 设w=[10,8,5],c1=16,c2=8。其搜索空间如下图所示，结点的左子树表示将此集装箱上船，右子树表示不将此集装箱上船，节点中的值表示当前装入第一艘船的集装箱的总重量。

    ![1542543555699](C:\Users\16500\AppData\Local\Temp\1542543555699.png)

* 批处理作业调度

  

| t     | 机器1 | 机器2 |
| ----- | ----- | ----- |
| 作业1 | 2     | 1     |
| 作业2 | 3     | 1     |
| 作业3 | 3     | 3     |

这3个作业的6种可能的调度方案是`1,2,3`；`1,3,2`；`2,1,3`；`2,3,1`；`3,1,2`；`3,2,1`；它们所相应的完成时间和分别是19，18，20，21，19，19。易见，最佳调度方案是1,3,2，其完成时间和为18。

* 1，2，3

  |       | 机器1 | 机器2 | 总时间 |
  | ----- | ----- | ----- | ------ |
  | 作业1 | 2     | 1     | 3      |
  | 作业2 | 5     | 1     | 6      |
  | 作业3 | 7     | 3     | 10     |

* 1，3，2

|       | 机器1 | 机器2 | 总时间 |
| ----- | ----- | ----- | ------ |
| 作业1 | 2     | 1     | 3      |
| 作业2 | 7     | 1     | 8      |
| 作业3 | 4     | 3     | 7      |

最短时间为`3 + 8 + 7 = 18`。